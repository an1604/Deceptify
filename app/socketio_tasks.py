import threading

import requests
from flask import session, request, copy_current_request_context
from flask_socketio import SocketIO, emit, disconnect

socketio = None


class SocketIO_Manager(object):
    def __init__(self, app):
        self.async_mode = None
        self.socketio = SocketIO(app, async_mode=self.async_mode)
        self.thread_lock = threading.Lock()
        self.logs_thread = None
        self.telegram_updates_set = False
        self.telegram_updates_background_thread = None
        self.telegram_client = None

        self.run_default_events(self.socketio)
        self.socketio.run(app)  # Running the app with the socketio.

    def emit_event(self, event_name, *args, **kwargs):
        self.socketio.emit(event_name, *args, **kwargs)

    def set_telegram_client(self, t_client):
        self.telegram_client = t_client

    def set_telegram_updates_background_thread(self):
        self.telegram_updates_set = True

    def wait_for_updated_from_telegram_client(self):
        while True:
            if not self.telegram_updates_set:
                self.socketio.sleep(10)
            else:
                # TODO:
                #  NEED TO CHECK IF THERE ARE SOME NRE MESSAGES
                #  FORM THE TELEGRAM CLIENT APPLICATION TO UPDATE THE USER
                self.socketio.emit({'new_telegram_updates',
                                    {'data': 'Telegram updates is set'}})

    def run_default_events(self, socketio):
        @socketio.event
        def connect():
            print('Client connected')
            with self.thread_lock:
                if self.telegram_updates_background_thread is None:
                    self.telegram_updates_background_thread = socketio.start_background_task(
                        self.wait_for_updated_from_telegram_client)
            emit('update', {'data': 'Connected', 'count': 0}, broadcast=True)

        @socketio.event
        def new_telegram_update_event(message):
            emit('new_telegram_updates',
                 {'data': message['data']})

        @socketio.on('new_telegram_updates_request_from_user')  # User ask for new updates
        # (telegram messages from the target)
        def handle_new_telegram_update_event(message):
            print(f'New request for telegram update received - {message}')

        @socketio.on('new_user_response_for_telegram_updates')  # User accepts or rejects the response
        # generated by the server (voice clone record, llm message)
        def handle_new_user_response_for_telegram_updates(data):
            user_response = data.get('response')
            print(f"Received user response: {user_response}")

        @socketio.event
        def disconnect_request():
            @copy_current_request_context
            def can_disconnect():
                disconnect()

            emit('my_response',
                 {'data': 'Disconnected!'}, callback=can_disconnect)

        @socketio.on('disconnect')
        def test_disconnect():
            print('Client disconnected', request.sid)
    # TODO: ADD MORE REALTIME UPDATES AND COMMUNICATIONS, SUCH AS REALTIME LOGS FOR THE VOICE ATTACK
